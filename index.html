<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>문자 카운터 앱</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 적용 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 커스텀 스크롤바 스타일 */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* 경고 메시지 스타일 */
        .warning-message {
            color: #ef4444; /* Tailwind red-500 */
            font-weight: bold;
        }
        /* 텍스트 초과 부분 강조 스타일 */
        /* 이 부분은 텍스트에 직접 적용되는 색상입니다. */
        .highlight-red-text {
            color: #ef4444; /* Tailwind red-500 for text */
        }
        .highlight-blue-text {
            color: #3b82f6; /* Tailwind blue-500 for text */
        }
        /* 빌드 정보 컨테이너 스타일 */
        .build-info-container {
            position: absolute;
            top: 1rem; /* 상단에서 1rem (16px) 떨어지게 */
            right: 1rem; /* 오른쪽에서 1rem (16px) 떨어지게 */
            z-index: 20; /* 다른 요소보다 위에 오도록 z-index 높게 설정 */
            text-align: right;
            line-height: 1.2; /* 줄 간격 조정 */
        }
        /* 언어 선택기 위치 조정 */
        #languageSelector {
            position: absolute;
            top: 5rem; /* 빌드 정보 아래로 충분히 이동 */
            right: 1rem; /* 오른쪽 정렬 유지 */
            z-index: 10;
        }
        /* 앱 타이틀에 여백 추가 */
        #appTitle {
            margin-top: 7rem; /* 빌드 정보와 언어 선택기 공간 확보 */
        }

        /* 새로운 강조 배경색 스타일 */
        /* 초과 글자 (빨간색) */
        .bg-highlight-red {
            background-color: #fce7f3; /* Tailwind pink-100 */
        }
        /* 최대 문자 초과 (파란색) */
        .bg-highlight-blue {
            background-color: #e0f2fe; /* Tailwind blue-100 */
        }
        /* 최대 줄 수 초과 (녹색) */
        .bg-highlight-green {
            background-color: #d1fae5; /* Tailwind green-100 */
        }

        /* 세부 설정 체크박스 배경색 제거 (불필요한 보라색 배경 제거) */
        #toggleSettings:checked ~ span {
            /* 텍스트 색상만 유지, 배경색은 기본값으로 */
            color: #1f2937; /* gray-800 */
        }
        label:has(input[type="checkbox"]#toggleSettings:checked) {
            background-color: #f3f4f6; /* gray-100, 기본 배경색 */
            border-color: #e5e7eb; /* gray-200, 기본 테두리색 */
        }
        label:has(input[type="checkbox"]#toggleSettings:checked):hover {
            background-color: #e5e7eb; /* gray-200 */
        }


        /* 제외 옵션 체크박스 커스텀 색상 */
        /* 기본 (선택 안 됨) */
        .exclusion-label {
            background-color: #e5e7eb; /* gray-200 */
            border-color: #d1d5db; /* gray-300 */
            color: #4b5563; /* gray-700 */
        }
        .exclusion-label:hover {
            background-color: #d1d5db; /* gray-300 */
        }
        .exclusion-label span {
            color: #4b5563; /* gray-700 */
        }

        /* <> 태그 - 진분홍 */
        label:has(input[type="checkbox"]#excludeAngleBrackets:checked) {
            background-color: #ec4899; /* Pink 500 */
            border-color: #db2777; /* Pink 600 */
            color: #ffffff;
        }
        label:has(input[type="checkbox"]#excludeAngleBrackets:checked):hover {
            background-color: #db2777; /* Pink 600 */
        }
        #excludeAngleBrackets:checked ~ span {
            color: #ffffff;
        }
        /* <> 태그 - 톤다운된 연한 빨강 (선택 안 됨) */
        label:has(input[type="checkbox"]#excludeAngleBrackets:not(:checked)).exclusion-label {
            background-color: #fca5a5; /* Red 300 */
            border-color: #ef4444; /* Red 500 */
            color: #ef4444; /* Red 500 */
        }
        label:has(input[type="checkbox"]#excludeAngleBrackets:not(:checked)).exclusion-label:hover {
            background-color: #f87171; /* Red 400 */
        }
        label:has(input[type="checkbox"]#excludeAngleBrackets:not(:checked)).exclusion-label span {
            color: #ef4444; /* Red 500 */
        }


        /* [] 태그 - 연청색 */
        label:has(input[type="checkbox"]#excludeSquareBrackets:checked) {
            background-color: #38bdf8; /* Sky 400 */
            border-color: #0ea5e9; /* Sky 500 */
            color: #ffffff;
        }
        label:has(input[type="checkbox"]#excludeSquareBrackets:checked):hover {
            background-color: #0ea5e9; /* Sky 500 */
        }
        #excludeSquareBrackets:checked ~ span {
            color: #ffffff;
        }
        /* [] 태그 - 톤다운된 연한 파랑 (선택 안 됨) */
        label:has(input[type="checkbox"]#excludeSquareBrackets:not(:checked)).exclusion-label {
            background-color: #93c5fd; /* Blue 300 */
            border-color: #3b82f6; /* Blue 500 */
            color: #3b82f6; /* Blue 500 */
        }
        label:has(input[type="checkbox"]#excludeSquareBrackets:not(:checked)).exclusion-label:hover {
            background-color: #60a5fa; /* Blue 400 */
        }
        label:has(input[type="checkbox"]#excludeSquareBrackets:not(:checked)).exclusion-label span {
            color: #3b82f6; /* Blue 500 */
        }


        /* {} 태그 - 보라색 (새로 추가) */
        label:has(input[type="checkbox"]#excludeCurlyBrackets:checked) {
            background-color: #a855f7; /* Purple 500 */
            border-color: #9333ea; /* Purple 600 */
            color: #ffffff;
        }
        label:has(input[type="checkbox"]#excludeCurlyBrackets:checked):hover {
            background-color: #9333ea; /* Purple 600 */
        }
        #excludeCurlyBrackets:checked ~ span {
            color: #ffffff;
        }
        /* {} 태그 - 톤다운된 연한 보라 (선택 안 됨) */
        label:has(input[type="checkbox"]#excludeCurlyBrackets:not(:checked)).exclusion-label {
            background-color: #d8b4fe; /* Purple 300 */
            border-color: #a855f7; /* Purple 500 */
            color: #a855f7; /* Purple 500 */
        }
        label:has(input[type="checkbox"]#excludeCurlyBrackets:not(:checked)).exclusion-label:hover {
            background-color: #c084fc; /* Purple 400 */
        }
        label:has(input[type="checkbox"]#excludeCurlyBrackets:not(:checked)).exclusion-label span {
            color: #a855f7; /* Purple 500 */
        }


        /* 공백 / 개행 / 특수문자 - 검정 */
        label:has(input[type="checkbox"]#excludeSpaces:checked),
        label:has(input[type="checkbox"]#excludeNewlines:checked),
        label:has(input[type="checkbox"]#excludeSpecialCharacters:checked) { /* NEW */
            background-color: #1f2937; /* Gray 900 */
            border-color: #111827; /* Gray 950 */
            color: #ffffff;
        }
        label:has(input[type="checkbox"]#excludeSpaces:checked):hover,
        label:has(input[type="checkbox"]#excludeNewlines:checked):hover,
        label:has(input[type="checkbox"]#excludeSpecialCharacters:checked):hover { /* NEW */
            background-color: #111827; /* Gray 950 */
        }
        #excludeSpaces:checked ~ span,
        #excludeNewlines:checked ~ span,
        #excludeSpecialCharacters:checked ~ span { /* NEW */
            color: #ffffff;
        }

        /* 공백 / 개행 / 특수문자 - 톤다운된 연한 회색 (선택 안 됨) */
        label:has(input[type="checkbox"]#excludeSpaces:not(:checked)).exclusion-label,
        label:has(input[type="checkbox"]#excludeNewlines:not(:checked)).exclusion-label,
        label:has(input[type="checkbox"]#excludeSpecialCharacters:not(:checked)).exclusion-label { /* NEW */
            background-color: #e5e7eb; /* Gray 200 */
            border-color: #9ca3af; /* Gray 400 */
            color: #9ca3af; /* Gray 400 */
        }
        label:has(input[type="checkbox"]#excludeSpaces:not(:checked)).exclusion-label:hover,
        label:has(input[type="checkbox"]#excludeNewlines:not(:checked)).exclusion-label:hover,
        label:has(input[type="checkbox"]#excludeSpecialCharacters:not(:checked)).exclusion-label:hover { /* NEW */
            background-color: #d1d5db; /* Gray 300 */
        }
        label:has(input[type="checkbox"]#excludeSpaces:not(:checked)).exclusion-label span,
        label:has(input[type="checkbox"]#excludeNewlines:not(:checked)).exclusion-label span,
        label:has(input[type="checkbox"]#excludeSpecialCharacters:not(:checked)).exclusion-label span { /* NEW */
            color: #9ca3af; /* Gray 400 */
        }


        /* 텍스트 영역의 강조된 부분에만 적용될 스타일 */
        .highlight-red-inline {
            color: #ef4444; /* Tailwind red-500 */
        }
        .highlight-blue-inline {
            color: #3b82f6; /* Tailwind blue-500 */
        }
        /* 새로운 강조색: 보라색 ({} 태그용) */
        .highlight-purple-inline {
            color: #a855f7; /* Tailwind purple-500 */
        }

    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-2xl relative">
        <!-- Designed by 정보 (최상단 오른쪽) -->
        <div id="designedByInfo" class="build-info-container text-xs text-gray-500">
            Designed by Cindy Kim<br>Built by Gemini<br><span id="buildVersionDate"></span>
        </div>

        <!-- 언어 선택기 -->
        <div id="languageSelector" class="relative inline-block text-left">
            <button id="languageToggleButton" class="inline-flex justify-center items-center gap-x-1.5 rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50">
                <!-- Globe icon (similar to Lucide React's Globe icon) -->
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-globe">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/>
                    <path d="M2 12h20"/>
                </svg>
                <span id="currentLanguageText">한국어</span>
                <svg class="-mr-1 h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.23 8.29a.75.75 0 01.02-1.06z" clip-rule="evenodd" />
                </svg>
            </button>

            <div id="languageDropdown" class="absolute right-0 z-10 mt-2 w-40 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none hidden" role="menu" aria-orientation="vertical" aria-labelledby="languageToggleButton" tabindex="-1">
                <div class="py-1" role="none">
                    <!-- Language options will be dynamically populated here -->
                </div>
            </div>
        </div>

        <h1 id="appTitle" class="text-3xl font-bold text-gray-800 mb-6 text-center">문자 카운터 앱</h1>

        <!-- Settings section -->
        <div class="mb-6 border border-gray-200 rounded-lg p-4 bg-gray-50">
            <label class="flex items-center cursor-pointer mb-4">
                <input type="checkbox" id="toggleSettings" class="form-checkbox h-5 w-5 text-indigo-600 rounded">
                <span id="settingsLabel" class="ml-2 text-gray-800 font-bold text-lg">세부 설정</span>
            </label>

            <div id="settingsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 hidden">
                <div>
                    <label for="maxCharTotalInput" id="maxCharTotalLabel" class="block text-gray-700 text-sm font-semibold mb-1">최대 문자 수 (전체)</label>
                    <input type="number" id="maxCharTotalInput" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-indigo-500" min="0">
                </div>
                <div>
                    <label for="maxCharLineInput" id="maxCharLineLabel" class="block text-gray-700 text-sm font-semibold mb-1">최대 문자 수 (행별)</label>
                    <input type="number" id="maxCharLineInput" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-indigo-500" min="0">
                </div>
                <div>
                    <label for="maxLineInput" id="maxLineLabel" class="block text-gray-700 text-sm font-semibold mb-1">최대 줄 수</label>
                    <input type="number" id="maxLineInput" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-indigo-500" min="0">
                </div>
                <div id="maxWordsSettingContainer" class="hidden">
                    <label for="maxWordsInput" id="maxWordsLabel" class="block text-gray-700 text-sm font-semibold mb-1">최대 단어 수</label>
                    <input type="number" id="maxWordsInput" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-indigo-500" min="0">
                </div>
                <!-- Settings message board -->
                <div id="settingsMessageBoard" class="md:col-span-2 mt-4 p-3 rounded-md text-sm text-gray-600 bg-gray-100">
                    설정을 입력해 주세요.
                </div>
            </div>
        </div>

        <!-- Exclusion options section -->
        <div class="mb-6">
            <h2 id="exclusionOptionsTitle" class="text-lg font-bold text-gray-800 mb-4">제외 옵션</h2>
            <div class="flex flex-wrap justify-center gap-4 mb-4"> <!-- First row of tags -->
                <!-- Tag exclusion checkbox for angle brackets -->
                <label class="exclusion-label flex items-center cursor-pointer px-4 py-2 rounded-full transition-colors duration-200 shadow-md">
                    <input type="checkbox" id="excludeAngleBrackets" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                    <span id="labelExcludeAngleBrackets" class="ml-2 font-semibold"><> 태그</span>
                </label>

                <!-- Tag exclusion checkbox for square brackets -->
                <label class="exclusion-label flex items-center cursor-pointer px-4 py-2 rounded-full transition-colors duration-200 shadow-md">
                    <input type="checkbox" id="excludeSquareBrackets" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                    <span id="labelExcludeSquareBrackets" class="ml-2 font-semibold">[] 태그</span>
                </label>

                <!-- Tag exclusion checkbox for curly braces (NEW) -->
                <label class="exclusion-label flex items-center cursor-pointer px-4 py-2 rounded-full transition-colors duration-200 shadow-md">
                    <input type="checkbox" id="excludeCurlyBrackets" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                    <span id="labelExcludeCurlyBrackets" class="ml-2 font-semibold">{} 태그</span>
                </label>
            </div>
            <div class="flex flex-wrap justify-center gap-4"> <!-- Second row of special chars, spaces, newlines -->
                <!-- Special Character exclusion checkbox (NEW) -->
                <label class="exclusion-label flex items-center cursor-pointer px-4 py-2 rounded-full transition-colors duration-200 shadow-md">
                    <input type="checkbox" id="excludeSpecialCharacters" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span id="labelExcludeSpecialCharacters" class="ml-2 font-semibold">특수문자</span>
                </label>

                <!-- Space exclusion checkbox -->
                <label class="exclusion-label flex items-center cursor-pointer px-4 py-2 rounded-full transition-colors duration-200 shadow-md">
                    <input type="checkbox" id="excludeSpaces" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span id="labelExcludeSpaces" class="ml-2 font-semibold">공백</span>
                </label>

                <!-- Newline exclusion checkbox -->
                <label class="exclusion-label flex items-center cursor-pointer px-4 py-2 rounded-full transition-colors duration-200 shadow-md">
                    <input type="checkbox" id="excludeNewlines" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
                    <span id="labelExcludeNewlines" class="ml-2 font-semibold">개행</span>
                </label>
            </div>
        </div>

        <!-- Character counting mode selector (Dropdown) -->
        <div class="mb-6">
            <h2 id="countingModeLabel" class="text-lg font-bold text-gray-800 mb-2">문자 카운트 모드</h2>
            <div id="countingModeSelector" class="relative inline-block text-left w-full sm:w-auto">
                <button id="countingModeToggleButton" type="button" class="inline-flex justify-between items-center w-full rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-100">
                    <span id="currentCountingModeText">전각 기준</span>
                    <svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 10.94l3.71-3.71a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.23 8.29a.75.75 0 01.02-1.06z" clip-rule="evenodd" />
                    </svg>
                </button>
                <div id="countingModeDropdown" class="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden" role="menu" aria-orientation="vertical" aria-labelledby="countingModeToggleButton" tabindex="-1">
                    <div class="py-1" role="none">
                        <!-- Language options will be dynamically populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Count results display area (Moved above text input) -->
        <!-- Adjusted to use grid layout for better control over column arrangement -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div class="bg-blue-50 p-4 rounded-lg shadow-sm">
                <h2 id="totalCharCountTitle" class="text-lg font-semibold text-blue-700 mb-2">문자 수</h2>
                <p id="totalCharCount" class="text-4xl font-extrabold text-blue-900">0</p>
            </div>
            <div class="bg-green-50 p-4 rounded-lg shadow-sm">
                <h2 id="totalLineCountTitle" class="text-lg font-semibold text-green-700 mb-2">줄 수</h2>
                <p id="totalLineCount" class="text-4xl font-extrabold text-green-900">0</p>
            </div>
            <div id="wordCountContainer" class="bg-purple-50 p-4 rounded-lg shadow-sm hidden">
                <h2 id="totalWordCountTitle" class="text-lg font-semibold text-purple-700 mb-2">단어 수</h2>
                <p id="totalWordCount" class="text-4xl font-extrabold text-purple-900">0</p>
            </div>
        </div>

        <!-- Text input area -->
        <div class="mb-6">
            <textarea
                id="textInput"
                class="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 h-64 resize-y custom-scrollbar"
                placeholder="텍스트를 입력하면 실시간으로 문자 수가 계산됩니다."
            ></textarea>
        </div>

        <!-- Highlighted/Excluded text display area (Moved here) -->
        <div id="highlightedTextDisplay" class="mt-4 p-4 border border-gray-300 rounded-lg bg-gray-50 max-h-48 overflow-y-auto custom-scrollbar whitespace-pre-wrap">
            <!-- Emphasized or excluded text will be displayed here -->
            텍스트를 입력하시면 태그 강조 또는 제외된 내용이 여기에 표시됩니다.
        </div>


        <!-- Character count per line display area -->
        <div class="bg-yellow-50 p-4 rounded-lg shadow-sm mt-6"> <!-- Adjusted margin-top -->
            <h2 id="lineCharCountsTitle" class="text-lg font-semibold text-yellow-700 mb-2">행별 문자 수</h2>
            <div id="lineCharCounts" class="text-gray-800 text-sm max-h-48 overflow-y-auto custom-scrollbar">
                <!-- Line-by-line count results will be dynamically displayed here. -->
                <p id="noTextPrompt" class="text-gray-500">텍스트를 입력하면 각 행의 문자 수가 표시됩니다.</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const getDomElements = () => {
                const ids = [
                    'textInput', 'appTitle', 'totalCharCount', 'totalCharCountTitle',
                    'totalLineCount', 'totalLineCountTitle', 'lineCharCounts', 'lineCharCountsTitle',
                    'noTextPrompt', 'totalWordCount', 'totalWordCountTitle', 'wordCountContainer',
                    'buildVersionDate', 'languageToggleButton', 'languageDropdown',
                    'currentLanguageText', 'languageSelector', 'countingModeToggleButton',
                    'countingModeDropdown', 'currentCountingModeText', 'countingModeSelector',
                    'excludeAngleBrackets', 'labelExcludeAngleBrackets',
                    'excludeSquareBrackets', 'labelExcludeSquareBrackets',
                    'excludeCurlyBrackets', 'labelExcludeCurlyBrackets', // NEW: Curly Brackets
                    'excludeSpecialCharacters', 'labelExcludeSpecialCharacters', // NEW: Special Characters
                    'excludeSpaces', 'labelExcludeSpaces',
                    'excludeNewlines', 'labelExcludeNewlines',
                    'toggleSettings', 'settingsLabel', 'settingsContainer', 'maxCharTotalInput',
                    'maxCharTotalLabel', 'maxCharLineInput', 'maxCharLineLabel', 'maxLineInput',
                    'maxLineLabel', 'maxWordsInput', 'maxWordsLabel', 'maxWordsSettingContainer',
                    'settingsMessageBoard', 'exclusionOptionsTitle', 'countingModeLabel',
                    'highlightedTextDisplay'
                ];
                const elements = {};
                ids.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        elements[id] = element;
                    } else {
                        console.error(`Error: Element with ID '${id}' not found. Please check HTML.`);
                    }
                });
                return elements;
            };

            const dom = getDomElements();

            // --- State Variables ---
            let currentLanguage = 'ko';
            let countingMode = 'fullWidthBasis';
            let excludeAngleBrackets = true;
            let excludeSquareBrackets = true;
            let excludeCurlyBrackets = true; // NEW: Curly Brackets exclusion state
            let excludeSpecialCharacters = false; // NEW: Special Characters exclusion state (default: false)
            let excludeSpaces = false;
            let excludeNewlines = true; // Initial state set to true by default in the code
            let settingsEnabled = false;

            // --- Translations ---
            const translations = {
                ko: {
                    appTitle: '문자 카운터 앱',
                    placeholder: '텍스트를 입력하면 실시간으로 문자 수가 계산됩니다.',
                    charCountLabel: '문자 수',
                    lineCountLabel: '줄 수',
                    lineCharCountTitle: '행별 문자 수',
                    linePrefix: '행',
                    charUnit: '문자',
                    noTextPrompt: '텍스트를 입력하면 각 행의 문자 수가 표시됩니다.',
                    langName: '한국어', // Explicitly ensured for clarity
                    wordCountSupported: false,
                    wordCountLabel: '단어 수',
                    exclusionOptionsTitle: '제외 옵션',
                    angleBracketExclusionLabel: '<> 태그', // Updated label
                    squareBracketExclusionLabel: '[] 태그', // Updated label
                    curlyBracketExclusionLabel: '{} 태그', // NEW: Curly Brackets label
                    specialCharExclusionLabel: '특수문자', // NEW: Special Characters label
                    spaceExclusionLabel: '공백',
                    newlineExclusionLabel: '개행',
                    settingsLabel: '세부 설정',
                    maxCharTotalLabel: '최대 문자 수 (전체)',
                    maxCharLineLabel: '최대 문자 수 (행별)',
                    maxLineLabel: '최대 줄 수',
                    maxWordsLabel: '최대 단어 수',
                    settingsPrompt: '설정을 입력해 주세요.',
                    countingModes: {
                        fullWidthBasis: '전각 기준',
                        halfWidthBasis: '반각 기준',
                        mixedWidth: '전각+반각 혼합'
                    },
                    countingModeLabel: '문자 카운트 모드',
                    maxCharTotalExceeded: '최대 문자 수(전체)를 초과했습니다!',
                    maxCharLineExceeded: '최대 문자 수(행별)를 초과하는 행이 있습니다! ({count}개)',
                    maxLineExceeded: '최대 줄 수를 초과했습니다!',
                    maxWordsExceeded: '최대 단어 수를 초과했습니다!'
                },
                en: {
                    appTitle: 'Character Counter App',
                    placeholder: 'Enter text to count characters in real-time.',
                    charCountLabel: 'Characters',
                    lineCountLabel: 'Lines',
                    lineCharCountTitle: 'Characters per Line',
                    linePrefix: 'Line', // Corrected: Added 'Line'
                    charUnit: 'characters', // Corrected: Added 'characters'
                    noTextPrompt: 'Enter text to see character counts per line.',
                    langName: 'English',
                    wordCountSupported: true,
                    wordCountLabel: 'Words', // NEW: Added wordCountLabel for English
                    exclusionOptionsTitle: 'Exclusion Options',
                    angleBracketExclusionLabel: '<> Tags', // Updated label
                    squareBracketExclusionLabel: '[] Tags', // Updated label
                    curlyBracketExclusionLabel: '{} Tags', // NEW: Curly Brackets label
                    specialCharExclusionLabel: 'Special Characters', // NEW: Special Characters label
                    spaceExclusionLabel: 'Spaces',
                    newlineExclusionLabel: 'Newlines',
                    settingsLabel: 'Detailed Settings',
                    maxCharTotalLabel: 'Max Characters (Total)',
                    maxCharLineLabel: 'Max Characters (Per Line)',
                    maxLineLabel: 'Max Lines',
                    maxWordsLabel: 'Words', // This is still used for the input label
                    settingsPrompt: 'Please enter settings.',
                    countingModes: {
                        fullWidthBasis: 'Full-width Basis',
                        halfWidthBasis: 'Half-width Basis',
                        mixedWidth: 'Full/Half-width Mixed'
                    },
                    countingModeLabel: 'Character Counting Mode',
                    maxCharTotalExceeded: 'Max total characters exceeded!',
                    maxCharLineExceeded: 'Lines exceeding max characters per line: ({count})',
                    maxLineExceeded: 'Max lines exceeded!',
                    maxWordsExceeded: 'Max words exceeded!'
                },
                ja: {
                    appTitle: '文字カウンターアプリ',
                    placeholder: 'テキストを入力すると、リアルタイムで文字数がカウントされます。',
                    charCountLabel: '文字数',
                    lineCountLabel: '行数',
                    lineCharCountTitle: '行ごとの文字数',
                    linePrefix: '行',
                    charUnit: '文字',
                    noTextPrompt: 'テキストを入力すると、各行の文字数が表示されます。',
                    langName: '日本語',
                    wordCountSupported: false,
                    wordCountLabel: '単語数',
                    exclusionOptionsTitle: '除外オプション',
                    angleBracketExclusionLabel: '<>タグ',
                    squareBracketExclusionLabel: '[]タグ',
                    curlyBracketExclusionLabel: '{}タグ',
                    specialCharExclusionLabel: '特殊文字', // NEW: Special Characters label
                    spaceExclusionLabel: '空白',
                    newlineExclusionLabel: '改行',
                    settingsLabel: '詳細設定',
                    maxCharTotalLabel: '最大文字数 (全体)',
                    maxCharLineLabel: '最大文字数 (行ごと)',
                    maxLineLabel: '最大行数',
                    maxWordsLabel: '最大単語数',
                    settingsPrompt: '設定を入力してください。',
                    countingModes: {
                        fullWidthBasis: '全角ベース',
                        halfWidthBasis: '半각ベース',
                        mixedWidth: '全각/半각混合'
                    },
                    countingModeLabel: '文字カウントモード',
                    maxCharTotalExceeded: '最大文字数(全体)を超過しました！',
                    maxCharLineExceeded: '最大文字数(行ごと)を超過する行があります！ ({count}개)',
                    maxLineExceeded: '最大行数を超過しました！',
                    maxWordsExceeded: '最大단어数を超過しました！'
                }
            };

            // --- Utility Functions ---

            /**
             * 태그(<>, [], {}), 특수문자, 공백, 개행을 제거하는 함수입니다.
             * 이 함수는 주로 문자 수 계산에 사용됩니다.
             * @param {string} textString - 처리할 문자열
             * @returns {string} 처리된 문자열
             */
            function processTextForCounting(textString) {
                let processedString = textString;
                if (excludeAngleBrackets) {
                    processedString = processedString.replace(/<[^>]*>/g, '');
                }
                if (excludeSquareBrackets) {
                    processedString = processedString.replace(/\[[^\]]*\]/g, '');
                }
                if (excludeCurlyBrackets) {
                    processedString = processedString.replace(/\{[^}]*\}/g, '');
                }
                if (excludeSpecialCharacters) { // NEW: Special Characters exclusion
                    processedString = processedString.replace(/[^\p{L}\p{N}\s]/gu, ''); // 유니코드 문자, 숫자, 공백이 아닌 모든 것
                }
                if (excludeSpaces) {
                    processedString = processedString.replace(/\s/g, '');
                }
                if (excludeNewlines) {
                    processedString = processedString.replace(/\n/g, '');
                }
                return processedString;
            }

            /**
             * 특정 문자가 전각(Full-width) 문자인지 판단하는 함수입니다.
             * 유니코드 범위에 따라 전각 문자를 대략적으로 판단합니다.
             * @param {string} char - 검사할 문자
             * @returns {boolean} 전각 문자이면 true, 아니면 false
             */
            function isFullWidthChar(char) {
                const code = char.charCodeAt(0);
                return (
                    (code >= 0x1100 && code <= 0x11FF) || // Hangul Jamo
                    (code >= 0x2E80 && code <= 0x2FFF) || // CJK Radicals Supplement, etc.
                    (code >= 0x3040 && code <= 0x309F) || // Hiragana
                    (code >= 0x30A0 && code <= 0x30FF) || // Katakana
                    (code >= 0x3100 && code <= 0x312F) || // Bopomofo
                    (code >= 0x3130 && code <= 0x318F) || // Hangul Compatibility Jamo
                    (code >= 0x3190 && code <= 0x319F) || // Kanbun
                    (code >= 0x31A0 && code <= 0x31BF) || // Bopomofo Extended
                    (code >= 0x31F0 && code <= 0x31FF) || // Katakana Phonetic Extensions
                    (code >= 0x3200 && code <= 0x32FF) || // Enclosed CJK Letters and Months
                    (code >= 0x3300 && code <= 0x33FF) || // CJK Compatibility
                    (code >= 0x3400 && code <= 0x4DBF) || // CJK Unified Ideographs Extension A
                    (code >= 0x4E00 && code <= 0x9FFF) || // CJK Unified Ideographs
                    (code >= 0xA000 && code <= 0xA48F) || // Yi Syllables
                    (code >= 0xA490 && code <= 0xA4CF) || // Yi Radicals
                    (code >= 0xAC00 && code <= 0xD7AF) || // Hangul Syllables
                    (code >= 0xF900 && code <= 0xFAFF) || // CJK Compatibility Ideographs
                    (code >= 0xFE30 && code <= 0xFE4F) || // CJK Compatibility Forms
                    (code >= 0xFF00 && code <= 0xFFEF)     // Halfwidth and Fullwidth Forms (especially full-width ASCII)
                );
            }

            /**
             * 선택된 countingMode에 따라 문자열의 길이를 계산합니다.
             * @param {string} text - 길이를 계산할 문자열
             * @returns {number} 계산된 문자열 길이
             */
            function calculateLength(text) {
                if (countingMode === 'fullWidthBasis') {
                    return text.length;
                } else if (countingMode === 'halfWidthBasis') {
                    let count = 0;
                    for (let i = 0; i < text.length; i++) {
                        count += isFullWidthChar(text[i]) ? 2 : 1;
                    }
                    return count;
                } else if (countingMode === 'mixedWidth') {
                    let count = 0;
                    for (let i = 0; i < text.length; i++) {
                        count += isFullWidthChar(text[i]) ? 1 : 0.5;
                    }
                    return count;
                }
                return 0;
            }

            // --- UI Update Functions ---

            /**
             * 언어 드롭다운의 옵션을 업데이트합니다.
             */
            function updateLanguageDropdownOptions() {
                if (dom.languageDropdown) {
                    const languageDropdownContent = dom.languageDropdown.querySelector('.py-1');
                    if (languageDropdownContent) {
                        languageDropdownContent.innerHTML = ''; // Clear existing hardcoded options
                        console.log("Attempting to populate language dropdown."); // Debug log
                        for (const langKey in translations) {
                            const langData = translations[langKey];
                            console.log(`Adding language: ${langKey}, Name: ${langData.langName}`); // Debug log
                            const a = document.createElement('a');
                            a.href = "#";
                            a.classList.add('text-gray-700', 'block', 'px-4', 'py-2', 'text-sm', 'hover:bg-gray-100', 'rounded-md');
                            a.setAttribute('role', 'menuitem');
                            a.setAttribute('tabindex', '-1');
                            a.setAttribute('data-lang', langKey);
                            a.textContent = langData.langName;
                            languageDropdownContent.appendChild(a);
                        }
                    } else {
                        console.error("languageDropdownContent not found for language dropdown."); // Debug log
                    }
                } else {
                    console.error("languageDropdown not found."); // Debug log
                }
            }

            /**
             * 문자 카운트 모드 드롭다운의 텍스트와 옵션을 업데이트합니다.
             */
            function updateCountingModeDropdownOptions() {
                const lang = translations[currentLanguage];
                if (dom.currentCountingModeText) {
                    dom.currentCountingModeText.textContent = lang.countingModes[countingMode];
                }

                if (dom.countingModeDropdown) {
                    const countingModeDropdownContent = dom.countingModeDropdown.querySelector('.py-1');
                    if (countingModeDropdownContent) {
                        countingModeDropdownContent.innerHTML = '';
                        for (const modeKey in lang.countingModes) {
                            const modeText = lang.countingModes[modeKey];
                            const a = document.createElement('a');
                            a.href = "#";
                            a.classList.add('text-gray-700', 'block', 'px-4', 'py-2', 'text-sm', 'hover:bg-gray-100', 'rounded-md');
                            a.setAttribute('role', 'menuitem');
                            a.setAttribute('tabindex', '-1');
                            a.setAttribute('data-mode', modeKey);
                            a.textContent = modeText;
                            countingModeDropdownContent.appendChild(a);
                        }
                    }
                }
            }

            /**
             * 앱의 모든 UI 텍스트를 현재 선택된 언어로 업데이트합니다.
             */
            function updateUITexts() {
                const lang = translations[currentLanguage];

                dom.appTitle && (dom.appTitle.textContent = lang.appTitle);
                dom.textInput && (dom.textInput.placeholder = lang.placeholder);
                dom.totalCharCountTitle && (dom.totalCharCountTitle.textContent = lang.charCountLabel);
                dom.totalLineCountTitle && (dom.totalLineCountTitle.textContent = lang.lineCountLabel);
                dom.lineCharCountsTitle && (dom.lineCharCountsTitle.textContent = lang.lineCharCountTitle);
                dom.noTextPrompt && (dom.noTextPrompt.textContent = lang.noTextPrompt);
                dom.exclusionOptionsTitle && (dom.exclusionOptionsTitle.textContent = lang.exclusionOptionsTitle);
                dom.labelExcludeAngleBrackets && (dom.labelExcludeAngleBrackets.textContent = lang.angleBracketExclusionLabel);
                dom.labelExcludeSquareBrackets && (dom.labelExcludeSquareBrackets.textContent = lang.squareBracketExclusionLabel);
                dom.labelExcludeCurlyBrackets && (dom.labelExcludeCurlyBrackets.textContent = lang.curlyBracketExclusionLabel); // NEW: Curly Brackets label
                dom.labelExcludeSpecialCharacters && (dom.labelExcludeSpecialCharacters.textContent = lang.specialCharExclusionLabel); // NEW: Special Characters label
                dom.labelExcludeSpaces && (dom.labelExcludeSpaces.textContent = lang.spaceExclusionLabel);
                dom.labelExcludeNewlines && (dom.labelExcludeNewlines.textContent = lang.newlineExclusionLabel);
                dom.settingsLabel && (dom.settingsLabel.textContent = lang.settingsLabel);
                dom.maxCharTotalLabel && (dom.maxCharTotalLabel.textContent = lang.maxCharTotalLabel);
                dom.maxCharLineLabel && (dom.maxCharLineLabel.textContent = lang.maxCharLineLabel);
                dom.maxLineLabel && (dom.maxLineLabel.textContent = lang.maxLineLabel);
                dom.maxWordsLabel && (dom.maxWordsLabel.textContent = lang.maxWordsLabel);
                dom.countingModeLabel && (dom.countingModeLabel.textContent = lang.countingModeLabel);

                if (dom.maxWordsSettingContainer) {
                    if (lang.wordCountSupported) {
                        dom.maxWordsSettingContainer.classList.remove('hidden');
                    } else {
                        dom.maxWordsSettingContainer.classList.add('hidden');
                    }
                }
                dom.currentLanguageText && (dom.currentLanguageText.textContent = lang.langName);
            }

            /**
             * 설정 메시지 보드를 업데이트하고 유효성 검사를 수행합니다.
             */
            function updateSettingsMessageBoard(currentTotalCharCount, currentTotalLineCount, currentTotalWordCount) {
                const lang = translations[currentLanguage];
                let messages = [];
                let hasWarning = false;

                const maxCharTotal = dom.maxCharTotalInput ? parseFloat(dom.maxCharTotalInput.value) : NaN;
                const maxCharLine = dom.maxCharLineInput ? parseFloat(dom.maxCharLineInput.value) : NaN;
                const maxLine = dom.maxLineInput ? parseFloat(dom.maxLineInput.value) : NaN;
                const maxWords = dom.maxWordsInput ? parseFloat(dom.maxWordsInput.value) : NaN;

                const anySettingEntered = !isNaN(maxCharTotal) || !isNaN(maxCharLine) || !isNaN(maxLine) || !isNaN(maxWords);

                if (!settingsEnabled) {
                    if (dom.settingsMessageBoard) {
                        dom.settingsMessageBoard.textContent = '';
                        dom.settingsMessageBoard.classList.remove('warning-message');
                    }
                    return;
                }

                if (!isNaN(maxCharTotal) && currentTotalCharCount > maxCharTotal) {
                    messages.push(lang.maxCharTotalExceeded);
                    hasWarning = true;
                }

                // 행별 문자 수 초과 메시지 추가
                if (!isNaN(maxCharLine)) {
                    let exceedingLineCount = 0;
                    const rawLinesForLineCharCheck = dom.textInput?.value.split('\n') || [];
                    rawLinesForLineCharCheck.forEach(rawLine => {
                        let processedLineForCharCount = rawLine; // Start with raw line for line-specific processing
                        if (excludeAngleBrackets) { processedLineForCharCount = processedLineForCharCount.replace(/<[^>]*>/g, ''); }
                        if (excludeSquareBrackets) { processedLineForCharCount = processedLineForCharCount.replace(/\[[^\]]*\]/g, ''); }
                        if (excludeCurlyBrackets) { processedLineForCharCount = processedLineForCharCount.replace(/\{[^}]*\}/g, ''); }
                        if (excludeSpecialCharacters) { processedLineForCharCount = processedLineForCharCount.replace(/[^\p{L}\p{N}\s]/gu, ''); } // NEW: Special Characters
                        if (excludeSpaces) { processedLineForCharCount = processedLineForCharCount.replace(/\s/g, ''); }
                        // For line length count, newlines are implicitly handled by splitting.
                        // We don't remove them if excludeNewlines is true, because we want length of THAT line.
                        // The `calculateLength` function will count based on the modified line.
                        // If excludeNewlines is checked globally, it only affects the total count, not line character count
                        // as a single line has no internal newlines to exclude from its length.

                        if (calculateLength(processedLineForCharCount) > maxCharLine) {
                            exceedingLineCount++;
                        }
                    });
                    if (exceedingLineCount > 0) {
                        messages.push(lang.maxCharLineExceeded.replace('{count}', exceedingLineCount));
                        hasWarning = true;
                    }
                }

                // 최대 줄 수 초과 메시지 추가
                if (!isNaN(maxLine) && currentTotalLineCount > maxLine) {
                    messages.push(lang.maxLineExceeded);
                    hasWarning = true;
                }

                if (lang.wordCountSupported && !isNaN(maxWords) && currentTotalWordCount > maxWords) {
                    messages.push(lang.maxWordsExceeded);
                    hasWarning = true;
                }

                if (dom.settingsMessageBoard) {
                    if (messages.length === 0) {
                        dom.settingsMessageBoard.textContent = anySettingEntered ? '' : lang.settingsPrompt;
                        dom.settingsMessageBoard.classList.remove('warning-message');
                    } else {
                        dom.settingsMessageBoard.innerHTML = messages.join('<br>');
                        dom.settingsMessageBoard.classList.add('warning-message');
                    }
                }
            }

            /**
             * 텍스트 영역 아래 강조/제외 텍스트 표시 영역을 업데이트합니다.
             * 원본 텍스트에서 태그가 제외되지 않았다면 강조 표시하고,
             * 태그가 제외되었다면 제외된 내용만 표시합니다.
             */
            function updateHighlightedTextDisplay(rawInputText) {
                if (!dom.highlightedTextDisplay) return;

                let outputHtml = rawInputText;

                // 1. 모든 HTML 특수 문자를 HTML 엔티티로 변환하여 텍스트로 표시되도록 합니다.
                // 이 단계에서 <br> 같은 태그는 &lt;br&gt;로 변환됩니다.
                outputHtml = outputHtml.replace(/&/g, '&amp;')
                                      .replace(/</g, '&lt;')
                                      .replace(/>/g, '&gt;')
                                      .replace(/"/g, '&quot;')
                                      .replace(/'/g, '&#039;');


                // 2. 태그 및 특수문자 처리: 제외 옵션이 켜져 있으면 제거, 꺼져 있으면 강조 (태그만 해당)
                // <> 태그
                if (dom.excludeAngleBrackets.checked) {
                    outputHtml = outputHtml.replace(/&lt;[^&]*?&gt;/g, ''); // HTML 엔티티화된 태그 제거
                } else {
                    outputHtml = outputHtml.replace(/(&lt;[^&]*?&gt;)/g, '<span class="highlight-red-inline">$1</span>');
                }

                // [] 태그
                if (dom.excludeSquareBrackets.checked) {
                    outputHtml = outputHtml.replace(/\[[^\]]*?\]/g, '');
                } else {
                    outputHtml = outputHtml.replace(/(\[[^\]]*?\])/g, '<span class="highlight-blue-inline">$1</span>');
                }

                // {} 태그
                if (dom.excludeCurlyBrackets.checked) {
                    outputHtml = outputHtml.replace(/\{[^}]*?\}/g, '');
                } else {
                    outputHtml = outputHtml.replace(/(\{[^}]*?\})/g, '<span class="highlight-purple-inline">$1</span>');
                }

                // 특수문자 (언어에 관계없이 처리해야 하므로 \p{L}\p{N}\s를 사용)
                // 특수문자는 제외하지 않을 경우 별도로 강조하지 않으므로 else 블록 없음.
                if (dom.excludeSpecialCharacters.checked) {
                    outputHtml = outputHtml.replace(/[^\p{L}\p{N}\s]/gu, ''); // 유니코드 문자, 숫자, 공백이 아닌 모든 것을 제거
                }

                // 3. 공백 및 개행 문자 처리
                if (dom.excludeNewlines.checked) {
                    outputHtml = outputHtml.replace(/\n/g, ' ');
                }

                if (dom.excludeSpaces.checked) {
                    outputHtml = outputHtml.replace(/\s+/g, '');
                } else {
                    outputHtml = outputHtml.replace(/\s+/g, ' ').trim();
                }

                dom.highlightedTextDisplay.innerHTML = outputHtml;
            }


            /**
             * 행별 문자 수 표시 영역을 업데이트합니다.
             */
            function updateLineCharCountsDisplay() {
                const lang = translations[currentLanguage];
                if (dom.lineCharCounts) {
                    dom.lineCharCounts.innerHTML = '';

                    const originalLines = dom.textInput?.value.split('\n') || [];

                    if (originalLines.length === 0 || (originalLines.length === 1 && originalLines[0].trim() === '')) {
                        dom.noTextPrompt && dom.lineCharCounts.appendChild(dom.noTextPrompt);
                    } else {
                        originalLines.forEach((originalLine, index) => {
                            let lineForCounting = originalLine;
                            // Apply all exclusions to the line for its character count
                            if (excludeAngleBrackets) { lineForCounting = lineForCounting.replace(/<[^>]*>/g, ''); }
                            if (excludeSquareBrackets) { lineForCounting = lineForCounting.replace(/\[[^\]]*\]/g, ''); }
                            if (excludeCurlyBrackets) { lineForCounting = lineForCounting.replace(/\{[^}]*\}/g, ''); }
                            if (excludeSpecialCharacters) { lineForCounting = lineForCounting.replace(/[^\p{L}\p{N}\s]/gu, ''); } // NEW
                            if (excludeSpaces) { lineForCounting = lineForCounting.replace(/\s/g, ''); }
                            // Newlines within a single line are not relevant for its character count.
                            // The line itself doesn't contain '\n' unless it's a multiline string in `originalLine`,
                            // which is handled by `split('\n')`.

                            const lineElement = document.createElement('p');
                            // 텍스트를 구성할 때 linePrefix와 charUnit을 사용하여 다국어 지원
                            lineElement.textContent = `${index + 1}${lang.linePrefix}: ${calculateLength(lineForCounting)} ${lang.charUnit}`;

                            // 기존 강조 클래스 제거 (텍스트 색상 및 배경색)
                            lineElement.classList.remove('highlight-red-text', 'bg-highlight-blue', 'bg-highlight-green');

                            if (settingsEnabled) {
                                const maxCharLine = dom.maxCharLineInput ? parseFloat(dom.maxCharLineInput.value) : NaN;
                                const maxLine = dom.maxLineInput ? parseFloat(dom.maxLineInput.value) : NaN;

                                const currentLineCharCount = calculateLength(lineForCounting);
                                const isCurrentLineExceedingMaxCharLine = !isNaN(maxCharLine) && currentLineCharCount > maxCharLine;
                                const isCurrentLineExceedingMaxLines = !isNaN(maxLine) && (index + 1) > maxLine;

                                // 2. 세부 설정했을 때
                                // 1) 행 수를 초과할 때: 해당 부분의 텍스트는 "빨간색"으로, 배경색은 "연한 녹색"으로
                                if (isCurrentLineExceedingMaxLines) {
                                    lineElement.classList.add('highlight-red-text', 'bg-highlight-green');
                                }
                                // 2) 행별 문자 수를 초과할 때: 해당 부분의 텍스트는 "빨간색"으로, 배경색은 "연한 파란색"으로
                                else if (isCurrentLineExceedingMaxCharLine) { // else if를 사용하여 둘 중 하나만 적용되도록
                                    lineElement.classList.add('highlight-red-text', 'bg-highlight-blue');
                                }
                                // 그 외의 세부 설정 활성화 시 행은 기본색상
                            } else {
                                // 1. 세부 설정을 하지 않았을 때: 행별 문자 수에 표시되는 모든 텍스트는 검은색으로 표시되며, 바탕색도 없어요.
                                // 이 경우 아무 클래스도 추가하지 않아 기본 검은색 텍스트와 배경 없음 유지
                            }
                            
                            lineElement.classList.add('py-1', 'border-b', 'border-yellow-100', 'last:border-b-0');
                            dom.lineCharCounts.appendChild(lineElement);
                        });
                    }
                }
            }

            /**
             * 모든 카운트(문자, 줄, 단어)를 계산하고 UI를 업데이트하는 메인 함수입니다.
             */
            function updateCounts() {
                const lang = translations[currentLanguage];
                const rawInputText = dom.textInput?.value || '';

                // --- 1. Total Character Count ---
                // processTextForCounting 함수를 사용하여 모든 제외 옵션을 적용한 텍스트로 계산
                let textForTotalCharCount = processTextForCounting(rawInputText);
                
                const currentTotalCharCount = calculateLength(textForTotalCharCount);
                dom.totalCharCount && (dom.totalCharCount.textContent = currentTotalCharCount);
                dom.totalCharCountTitle && (dom.totalCharCountTitle.textContent = `${lang.charCountLabel} (${lang.countingModes[countingMode]})`);

                const totalCharCountBox = dom.totalCharCount.closest('.bg-blue-50');
                if (totalCharCountBox) {
                    totalCharCountBox.classList.remove('bg-highlight-red'); // 항상 제거
                }


                // --- 2. Total Line Count ---
                const originalLines = rawInputText.split('\n');
                const currentTotalLineCount = originalLines.length;
                dom.totalLineCount && (dom.totalLineCount.textContent = currentTotalLineCount);
                dom.totalLineCountTitle && (dom.totalLineCountTitle.textContent = lang.lineCountLabel);

                // --- 3. Word Count ---
                // 단어 수 계산에는 태그와 특수문자 제거, 공백은 단어 구분자로 사용
                let textForWordCount = rawInputText;
                if (excludeAngleBrackets) { textForWordCount = textForWordCount.replace(/<[^>]*>/g, ''); }
                if (excludeSquareBrackets) { textForWordCount = textForWordCount.replace(/\[[^\]]*\]/g, ''); }
                if (excludeCurlyBrackets) { textForWordCount = textForWordCount.replace(/\{[^}]*\}/g, ''); }
                if (excludeSpecialCharacters) { textForWordCount = textForWordCount.replace(/[^\p{L}\p{N}\s]/gu, ''); } // NEW

                let currentTotalWordCount = 0;
                if (lang.wordCountSupported) {
                    // Split by any whitespace (including newlines) and filter out empty strings
                    const words = textForWordCount.split(/\s+/).filter(word => word.length > 0);
                    currentTotalWordCount = words.length;
                    dom.totalWordCount && (dom.totalWordCount.textContent = `${currentTotalWordCount} ${lang.wordCountLabel}`);
                    dom.wordCountContainer && dom.wordCountContainer.classList.remove('hidden');
                    dom.totalWordCountTitle && (dom.totalWordCountTitle.textContent = lang.wordCountLabel);
                } else {
                    dom.wordCountContainer && dom.wordCountContainer.classList.add('hidden');
                }

                // --- Update Settings Message Board and Line-by-Line Display ---
                updateSettingsMessageBoard(currentTotalCharCount, currentTotalLineCount, currentTotalWordCount); // Pass all relevant counts
                updateLineCharCountsDisplay(); // This function now internally gets lines from textInput.value

                // 텍스트 영역에 시각적 강조를 위한 새로운 로직 적용 (textarea의 한계로 div를 사용)
                updateHighlightedTextDisplay(rawInputText);
            }

            /**
             * 앱의 모든 UI 텍스트와 드롭다운 옵션을 업데이트합니다.
             */
            function updateLanguage() {
                updateUITexts();
                updateLanguageDropdownOptions();
                updateCountingModeDropdownOptions();
                updateCounts(); // 언어 변경 시 카운트 재계산 및 메시지 업데이트
            }

            // --- Event Listeners ---
            function attachEventListeners() {
                dom.textInput?.addEventListener('input', updateCounts);

                dom.languageToggleButton?.addEventListener('click', (event) => {
                    event.stopPropagation();
                    dom.languageDropdown?.classList.toggle('hidden');
                    dom.countingModeDropdown?.classList.add('hidden');
                });

                dom.languageDropdown?.addEventListener('click', (event) => {
                    event.preventDefault();
                    const selectedLang = event.target.dataset.lang;
                    if (selectedLang && translations[selectedLang]) {
                        currentLanguage = selectedLang;
                        updateLanguage();
                        dom.languageDropdown?.classList.add('hidden');
                    }
                });

                dom.countingModeToggleButton?.addEventListener('click', (event) => {
                    event.stopPropagation();
                    dom.countingModeDropdown?.classList.toggle('hidden');
                    dom.languageDropdown?.classList.add('hidden');
                });

                dom.countingModeDropdown?.addEventListener('click', (event) => {
                    event.preventDefault();
                    const selectedMode = event.target.dataset.mode;
                    if (selectedMode) {
                        countingMode = selectedMode;
                        updateLanguage();
                        dom.countingModeDropdown?.classList.add('hidden');
                    }
                });

                // 새로운 `updateExclusionLabelColors` 함수를 호출하도록 변경
                dom.excludeAngleBrackets?.addEventListener('change', () => {
                    excludeAngleBrackets = dom.excludeAngleBrackets.checked;
                    updateCounts();
                    updateExclusionLabelColors(); // 상태 변경 시 라벨 색상 업데이트
                });

                dom.excludeSquareBrackets?.addEventListener('change', () => {
                    excludeSquareBrackets = dom.excludeSquareBrackets.checked;
                    updateCounts();
                    updateExclusionLabelColors(); // 상태 변경 시 라벨 색상 업데이트
                });

                dom.excludeCurlyBrackets?.addEventListener('change', () => {
                    excludeCurlyBrackets = dom.excludeCurlyBrackets.checked;
                    updateCounts();
                    updateExclusionLabelColors(); // 상태 변경 시 라벨 색상 업데이트
                });

                dom.excludeSpecialCharacters?.addEventListener('change', () => { // NEW
                    excludeSpecialCharacters = dom.excludeSpecialCharacters.checked;
                    updateCounts();
                    updateExclusionLabelColors(); // 상태 변경 시 라벨 색상 업데이트
                });

                dom.excludeSpaces?.addEventListener('change', () => {
                    excludeSpaces = dom.excludeSpaces.checked;
                    updateCounts();
                    updateExclusionLabelColors(); // 상태 변경 시 라벨 색상 업데이트
                });

                dom.excludeNewlines?.addEventListener('change', () => {
                    excludeNewlines = dom.excludeNewlines.checked;
                    updateCounts();
                    updateExclusionLabelColors(); // 상태 변경 시 라벨 색상 업데이트
                });

                dom.toggleSettings?.addEventListener('change', () => {
                    settingsEnabled = dom.toggleSettings.checked;
                    if (settingsEnabled) {
                        dom.settingsContainer?.classList.remove('hidden');
                        if (translations[currentLanguage].wordCountSupported) {
                            dom.maxWordsSettingContainer?.classList.remove('hidden');
                        } else {
                            dom.maxWordsSettingContainer?.classList.add('hidden');
                        }
                    } else {
                        dom.settingsContainer?.classList.add('hidden');
                        dom.settingsMessageBoard && (dom.settingsMessageBoard.textContent = '');
                        dom.settingsMessageBoard?.classList.remove('warning-message');
                        // 설정 해제 시 모든 강조 클래스 제거
                        dom.totalCharCount.closest('.bg-blue-50')?.classList.remove('bg-highlight-red'); // 전체 문자 수 박스 강조 제거
                        document.querySelectorAll('#lineCharCounts p').forEach(p => {
                            p.classList.remove('highlight-red-text', 'bg-highlight-blue', 'bg-highlight-green', 'bg-highlight-red'); // 모든 강조 클래스 제거
                        });
                    }
                    updateCounts(); // 설정 상태 변경 시 카운트 및 메시지 업데이트
                });

                dom.maxCharTotalInput?.addEventListener('input', updateCounts);
                dom.maxCharLineInput?.addEventListener('input', updateCounts);
                dom.maxLineInput?.addEventListener('input', updateCounts);
                dom.maxWordsInput?.addEventListener('input', updateCounts);

                document.addEventListener('click', (event) => {
                    if (dom.languageSelector && !dom.languageSelector.contains(event.target)) {
                        dom.languageDropdown?.classList.add('hidden');
                    }
                    if (dom.countingModeSelector && !dom.countingModeSelector.contains(event.target)) {
                        dom.countingModeDropdown?.classList.add('hidden');
                    }
                });
            }

            /**
             * 제외 옵션 라벨의 배경색과 텍스트 색상을 업데이트하는 함수 (선택 여부에 따라)
             */
            function updateExclusionLabelColors() {
                const exclusionLabels = document.querySelectorAll('.exclusion-label');
                exclusionLabels.forEach(label => {
                    const checkbox = label.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        // 모든 색상 클래스 초기화
                        label.classList.remove(
                            'bg-pink-500', 'border-pink-600', 'text-white', 'hover:bg-pink-600',
                            'bg-sky-400', 'border-sky-500', 'text-white', 'hover:bg-sky-500',
                            'bg-purple-500', 'border-purple-600', 'text-white', 'hover:bg-purple-600',
                            'bg-gray-900', 'border-gray-950', 'text-white', 'hover:bg-gray-950',
                            'bg-red-300', 'border-red-500', 'text-red-500', 'hover:bg-red-400',
                            'bg-blue-300', 'border-blue-500', 'text-blue-500', 'hover:bg-blue-400',
                            'bg-purple-300', 'border-purple-500', 'text-purple-500', 'hover:bg-purple-400',
                            'bg-gray-200', 'border-gray-400', 'text-gray-400', 'hover:bg-gray-300'
                        );
                        label.querySelector('span').classList.remove(
                            'text-white', 'text-red-500', 'text-blue-500', 'text-purple-500', 'text-gray-400'
                        );


                        if (checkbox.checked) {
                            // 선택된 상태
                            if (checkbox.id === 'excludeAngleBrackets') {
                                label.classList.add('bg-pink-500', 'border-pink-600', 'text-white', 'hover:bg-pink-600');
                                label.querySelector('span').classList.add('text-white');
                            } else if (checkbox.id === 'excludeSquareBrackets') {
                                label.classList.add('bg-sky-400', 'border-sky-500', 'text-white', 'hover:bg-sky-500');
                                label.querySelector('span').classList.add('text-white');
                            } else if (checkbox.id === 'excludeCurlyBrackets') {
                                label.classList.add('bg-purple-500', 'border-purple-600', 'text-white', 'hover:bg-purple-600');
                                label.querySelector('span').classList.add('text-white');
                            } else if (checkbox.id === 'excludeSpaces' || checkbox.id === 'excludeNewlines' || checkbox.id === 'excludeSpecialCharacters') { // NEW
                                label.classList.add('bg-gray-900', 'border-gray-950', 'text-white', 'hover:bg-gray-950');
                                label.querySelector('span').classList.add('text-white');
                            }
                        } else {
                            // 선택 안 된 상태 (톤다운된 색상)
                            if (checkbox.id === 'excludeAngleBrackets') {
                                label.classList.add('bg-red-300', 'border-red-500', 'text-red-500', 'hover:bg-red-400');
                                label.querySelector('span').classList.add('text-red-500');
                            } else if (checkbox.id === 'excludeSquareBrackets') {
                                label.classList.add('bg-blue-300', 'border-blue-500', 'text-blue-500', 'hover:bg-blue-400');
                                label.querySelector('span').classList.add('text-blue-500');
                            } else if (checkbox.id === 'excludeCurlyBrackets') {
                                label.classList.add('bg-purple-300', 'border-purple-500', 'text-purple-500', 'hover:bg-purple-400');
                                label.querySelector('span').classList.add('text-purple-500');
                            } else if (checkbox.id === 'excludeSpaces' || checkbox.id === 'excludeNewlines' || checkbox.id === 'excludeSpecialCharacters') { // NEW
                                label.classList.add('bg-gray-200', 'border-gray-400', 'text-gray-400', 'hover:bg-gray-300');
                                label.querySelector('span').classList.add('text-gray-400');
                            }
                        }
                    }
                });
            }


            // --- Initialization ---
            function initializeApp() {
                // 빌드 날짜 설정 (고정된 텍스트)
                dom.buildVersionDate && (dom.buildVersionDate.textContent = `Ver. 2.14 2025-08-11`); // 버전 업데이트

                // 기본 체크박스 상태 설정
                dom.excludeAngleBrackets && (dom.excludeAngleBrackets.checked = true);
                dom.excludeSquareBrackets && (dom.excludeSquareBrackets.checked = true);
                dom.excludeCurlyBrackets && (dom.excludeCurlyBrackets.checked = true);
                dom.excludeSpecialCharacters && (dom.excludeSpecialCharacters.checked = false); // NEW: Default to unchecked
                dom.excludeSpaces && (dom.excludeSpaces.checked = false);
                dom.excludeNewlines && (dom.excludeNewlines.checked = true); 
                dom.toggleSettings && (dom.toggleSettings.checked = false); // 세부 설정 기본은 비활성화

                // 초기 변수 값 업데이트
                excludeAngleBrackets = dom.excludeAngleBrackets.checked;
                excludeSquareBrackets = dom.excludeSquareBrackets.checked;
                excludeCurlyBrackets = dom.excludeCurlyBrackets.checked;
                excludeSpecialCharacters = dom.excludeSpecialCharacters.checked; // NEW
                excludeSpaces = dom.excludeSpaces.checked;
                excludeNewlines = dom.excludeNewlines.checked;


                updateLanguage(); // 초기 언어 설정 및 UI 업데이트
                attachEventListeners(); // 모든 이벤트 리스너 연결
                updateExclusionLabelColors(); // 초기 제외 옵션 라벨 색상 설정
            }

            initializeApp(); // 앱 초기화 함수 호출
        });
    </script>
</body>
</html>
